import React, { DependencyList, RefCallback, MutableRefObject, Ref, Dispatch, SetStateAction, EffectCallback, LegacyRef, RefObject, ChangeEvent, useEffect, Reducer, ReducerWithoutAction, DispatchWithoutAction } from 'react';
import { DebounceSettings, DebouncedFunc } from 'lodash';
import { FocusEvents, DOMAttributes } from '@react-types/shared';

interface LongHoverOptions {
    duration?: number;
}
declare const useOnLongHover: (callback: () => void, { duration }?: LongHoverOptions) => (node: HTMLElement | null) => void;

interface LongPressOptions {
    onClick?: (e: MouseEvent | TouchEvent) => void;
    duration?: number;
}
declare const useOnLongPress: (callback: () => void, { onClick, duration }?: LongPressOptions) => (node: HTMLElement | null) => void;

/**
 * useMapState hook
 * A hook to manage state in the form of a map or object.
 *
 * @param initialValue Initial value of the map
 * @see https://rooks.vercel.app/docs/useMapState
 */
declare function useMapState<T extends {
    [key: string]: unknown;
}, K extends keyof T>(initialValue: T): [
    T,
    {
        has: (key: K) => boolean;
        remove: (key: K) => void;
        removeAll: () => void;
        removeMultiple: (...keys: K[]) => void;
        set: (key: K, value: T[K]) => void;
        setMultiple: (next: Partial<T>) => void;
    }
];

type Push<T> = (...args: Parameters<Array<T>["push"]>) => void;
type Pop = () => void;
type Unshift<T> = (...args: Parameters<Array<T>["unshift"]>) => void;
type Shift = () => void;
type Reverse = () => void;
type Concat<T> = (value: T[]) => void;
type Fill<T> = (value: T, start?: number, end?: number) => void;
type UpdateItemAtIndex<T> = (index: number, value: T) => void;
type Clear = () => void;
type SetArray<T> = (value: T[]) => void;
type Splice<T> = (...args: Parameters<Array<T>["splice"]>) => void;
type RemoveItemAtIndex = (index: number) => void;
type ReplaceItemAtIndex<T> = (index: number, value: T) => void;
type InsertItemAtIndex<T> = (index: number, value: T) => void;
type Sort<T> = (compareFn?: (a: T, b: T) => number) => void;
type UseArrayStateControls<T> = {
    push: Push<T>;
    pop: Pop;
    clear: Clear;
    unshift: Unshift<T>;
    shift: Shift;
    reverse: Reverse;
    concat: Concat<T>;
    fill: Fill<T>;
    updateItemAtIndex: UpdateItemAtIndex<T>;
    setArray: SetArray<T>;
    splice: Splice<T>;
    removeItemAtIndex: RemoveItemAtIndex;
    replaceItemAtIndex: ReplaceItemAtIndex<T>;
    insertItemAtIndex: InsertItemAtIndex<T>;
    sort: Sort<T>;
};
type UseArrayStateReturnValue<T> = [T[], UseArrayStateControls<T>];
/**
 * useArrayState
 * @description Array state manager hook for React
 * @param {Array<T>} initialState Initial state of the array
 * @returns {UseArrayStateReturnValue<T>} Array state manager hook for React
 * @see {@link https://rooks.vercel.app/docs/useArrayState}
 *
 * @example
 *
 * const [array, controls] = useArrayState([1, 2, 3]);
 *
 * controls.push(4); // [1, 2, 3, 4]
 * controls.pop(); // [1, 2, 3]
 * controls.unshift(0); // [0, 1, 2, 3]
 * controls.shift(); // [1, 2, 3]
 * controls.reverse(); // [3, 2, 1]
 * controls.concat([4, 5, 6]); // [3, 2, 1, 4, 5, 6]
 * controls.fill(0); // [0, 0, 0, 0, 0, 0]
 * controls.updateItemAtIndex(0, 1); // [1, 0, 0, 0, 0, 0]
 * controls.clear(); // []
 * controls.setArray([1, 2, 3]); // [1, 2, 3]
 * controls.splice(1, 1); // [1, 3]
 * controls.removeItemAtIndex(1); // [1]
 * controls.replaceItemAtIndex(0, 2); // [2]
 * controls.insertItemAtIndex(0, 1); // [1, 2]
 * controls.sort((a, b) => a - b); // [1, 2]
 *
 */
declare function useArrayState<T>(initial: T[] | (() => T[])): UseArrayStateReturnValue<T>;

type Effect<T> = (shouldContinueEffect: () => boolean) => Promise<T>;
type CleanupFunction<T> = (result: T | void) => void;
/**
 * A version of useEffect that accepts an async function
 *
 * @param {Effect<T>} effect Async function that can return a cleanup function and takes in an AbortSignal
 * @param {DependencyList} deps If present, effect will only activate if the values in the list change
 * @param {CleanupFunction} cleanup The destroy/cleanup function. Will be called with previous result if it exists.
 * @see https://rooks.vercel.app/docs/useAsyncEffect
 * @example
 * ```jsx
 * useAsyncEffect(
        async (shouldContinueEffect) => {
          const data1 = await fetchData1(arg1, arg2);
          if(shouldContinueEffect()) {
            const data2 = await fetchData2(arg1, arg2);
          }
          ...
        },
        [arg1, arg2],
        (previousResult) => {
          // ... do something with previousResult ...
        }
      );
 * ```
 */
declare function useAsyncEffect<T>(effect: Effect<T>, deps: DependencyList, cleanup?: CleanupFunction<T>): void;

/**
 * useAudio
 * @description Audio hook
 * @see {@link https://rooks.vercel.app/docs/useAudio}
 */

type UseAudioOptions = {
    autoPlay?: boolean;
    isMuted?: boolean;
};
type UseAudioCallbacks = {
    onPlay?: () => void;
    onPause?: () => void;
    onMute?: () => void;
    onUnmute?: () => void;
    onLoadedMetadata?: () => void;
};
type AudioState = {
    isPlaying: boolean;
    isMuted: boolean;
};
type AudioControls = {
    play: () => void;
    pause: () => void;
    togglePlay: () => void;
    mute: () => void;
    unmute: () => void;
    toggleMute: () => void;
};
declare function useAudio(options?: UseAudioOptions, callbacks?: UseAudioCallbacks): [RefCallback<HTMLAudioElement>, AudioState, AudioControls];

/**
 * useBoundingclientRect hook
 *
 * @param ref The React ref whose ClientRect is needed
 * @returns DOMRect | null
 * @see https://rooks.vercel.app/docs/useBoundingclientRect
 */
declare function useBoundingclientrect(ref: MutableRefObject<HTMLElement | null>): DOMRect | null;

type HTMLElementOrNull = HTMLElement | null;
type RefElementOrNull<T> = T | null;
type CallbackRef<T extends HTMLElement | null = HTMLElementOrNull> = (node: T) => void;
type PossibleRef<T> = Ref<T> | undefined;

/**
 * useBoundingclientrectRef hook
 * Tracks the boundingclientrect of a React Ref and fires a callback when the element's size changes.
 *
 * @returns [CallbackRef | null, DOMRect | null, () => void]
 * @see https://rooks.vercel.app/docs/useBoundingclientRectRef
 */
declare function useBoundingclientrectRef(): [
    CallbackRef | null,
    DOMRect | null,
    () => void
];

type CountdownOptions = {
    interval?: number;
    onDown?: (restTime: number, newTime: Date) => void;
    onEnd?: (newTime: Date) => void;
};
/**
 *
 * useCountdown
 * Easy way to countdown until a given endtime in intervals
 *
 * @param endTime Time to countdown
 * @param options  Countdown options
 * @see https://rooks.vercel.app/docs/useCountdown
 */
declare function useCountdown(endTime: Date, options?: CountdownOptions): number;

type CounterHandler = {
    decrement: () => void;
    decrementBy: (amount: number) => void;
    increment: () => void;
    incrementBy: (amount: number) => void;
    reset: () => void;
    value: number;
};
/**
 *
 * @typedef handler
 * @type {object}
 * @property {number} value The value of the counter
 * @property {Function}  increment Increment counter value by 1
 * @property {Function} decrement Decrement counter value by 1
 * @property {Function} incrementBy Increment counter by incrAmount
 * @property {Function} decrementBy Decrement counter by decrAmount
 * @property {Function} reset Reset counter to initialValue
 * @see {@link https://rooks.vercel.app/docs/useCounter}
 */
/**
 * Counter hook
 *
 * @param {number} initialValue The initial value of the counter
 * @returns {handler} A handler to interact with the counter
 * @see https://rooks.vercel.app/docs/useCounter
 */
declare function useCounter(initialValue: number): CounterHandler;

type DeepNullable<T> = {
    [K in keyof T]: DeepNullable<T[K]> | null;
};
type ListenerOptions = boolean | {
    capture?: boolean;
    once?: boolean;
    passive?: boolean;
    signal?: AbortSignal;
};
type AnyFunction$1 = (...args: any[]) => any;
type ExcludeFunction<T> = Exclude<T, AnyFunction$1>;

/**
 * Debounce hook
 * Debounces a function
 *
 * @param callback The callback to debounce
 * @param wait The duration to debounce
 * @param options The options object.
 * @param options.leading Specify invoking on the leading edge of the timeout.
 * @param options.maxWait The maximum time func is allowed to be delayed before itâ€™s invoked.
 * @param options.trailing Specify invoking on the trailing edge of the timeout.
 * @returns Returns the new debounced function.
 * @see https://rooks.vercel.app/docs/useDebounce
 */
declare function useDebounce<T extends AnyFunction$1>(callback: T, wait?: number, options?: DebounceSettings): DebouncedFunc<T>;

type AnyFunction = (...args: unknown[]) => unknown;
type DebounceOptions = {
    leading?: boolean;
    trailing?: boolean;
    maxWait?: number;
};
declare function useDebounceFn<F extends AnyFunction>(func: F, delay: number, options?: DebounceOptions): [(...args: Parameters<F>) => void, boolean];

type UseDebouncedValueReturnType<TValue = unknown, TInitializeWithNull extends boolean = false> = [
    debouncedValue: TInitializeWithNull extends true ? TValue | null : TValue,
    immediatelyUpdateDebouncedValue: Dispatch<SetStateAction<TInitializeWithNull extends true ? TValue | null : TValue>>
];
/**
 * useDebouncedValue
 * @param value The value to debounce
 * @param timeout The duration to debounce
 * @param options The options object.
 * @see https://rooks.vercel.app/docs/useDebouncedValue
 */
declare const useDebouncedValue: <TValue = unknown, TInitializeWithNull extends boolean = false>(value: TValue, timeout: number, options?: Partial<{
    initializeWithNull: TInitializeWithNull;
}>) => UseDebouncedValueReturnType<TValue, TInitializeWithNull>;

/**
 * useDeepCompareEffect
 * @description Deep compare dependencies instead of shallow for useEffect
 * @see {@link https://rooks.vercel.app/docs/useDeepCompareEffect}
 */

declare function useDeepCompareEffect(callback: EffectCallback, dependencies: DependencyList): void;

type UseUndoStateOptions = {
    maxSize: number;
};
type UseUndoStatePushFunctionArgumentsCallback<T> = (currentValue: T) => T;
type UseUndoStatePushFunction<T> = (argument: T | UseUndoStatePushFunctionArgumentsCallback<T>) => void;
type UndoFunction = () => void;
type UseUndoStateReturnValue<T> = [
    ExcludeFunction<T>,
    UseUndoStatePushFunction<ExcludeFunction<T>>,
    UndoFunction
];
type CallbackWithNoArguments = () => void;
type UseGeolocationReturnType = {
    isError: boolean;
    lat?: number;
    lng?: number;
    message: string;
};

/**
 * useDidMount hook
 * @description Calls a function on mount
 *
 * @param {Function} callback Callback function to be called on mount
 * @see https://rooks.vercel.app/docs/useDidMount
 */
declare function useDidMount(callback: CallbackWithNoArguments): void;

/**
 *  useDidUpdate hook
 *
 *  Fires a callback on component update
 *  Can take in a list of conditions to fire callback when one of the
 *  conditions changes
 *
 * @param {Function} callback The callback to be called on update
 * @param {Array} conditions The list of variables which trigger update when they are changed
 * @see https://rooks.vercel.app/docs/useDidUpdate
 */
declare function useDidUpdate(callback: () => void, conditions?: unknown[]): void;

type UseDimensionsRefReturn = {
    bottom: number;
    height: number;
    left: number;
    right: number;
    top: number;
    width: number;
    x: number;
    y: number;
} | null;
type UseDimensionsHook = [
    LegacyRef<HTMLDivElement> | undefined,
    UseDimensionsRefReturn,
    HTMLElement | null
];
type UseDimensionsRefArgs = {
    updateOnResize?: boolean;
    updateOnScroll?: boolean;
};
/**
 * useDimensionsRef
 * @param updateOnScroll Whether to update on scroll
 * @param updateOnResize Whether to update on resize
 * @returns [React.Ref<HTMLDivElement>, UseDimensionsRefReturn, HTMLElement | null]
 * @see https://rooks.vercel.app/docs/useDimensionsRef
 */
declare const useDimensionsRef: ({ updateOnScroll, updateOnResize, }?: UseDimensionsRefArgs) => UseDimensionsHook;

/**
 *  useDocumentEventListener hook
 *
 * @description A react hook to an event listener to the document
 *
 * @param {keyof DocumentEventMap} eventName The event to track
 * @param {Function} callback The callback to be called on event
 * @param {ListenerOptions} listenerOptions The options to be passed to the event listener
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @see https://rooks.vercel.app/docs/useDocumentEventListener
 */
declare function useDocumentEventListener(eventName: keyof DocumentEventMap, callback: (...args: unknown[]) => void, listenerOptions?: ListenerOptions, isLayoutEffect?: boolean): void;

type UseDocumentTitleOptions = {
    resetOnUnmount?: boolean;
};
/**
 * useDocumentTitle hook
 *
 * This hook allows you to set the document title.
 *
 * @param title - The new title for the document
 * @param options - An optional object with a `resetOnUnmount` property to control whether the document title should be reset to its previous value when the component is unmounted. Defaults to false.
 *
 * @example
 * function App() {
 *   useDocumentTitle("My App", { resetOnUnmount: true });
 *   return <div>Hello, world!</div>;
 * }
 * @see {@link https://rooks.vercel.app/docs/useDocumentTitle}
 */
declare function useDocumentTitle(title: string, options?: UseDocumentTitleOptions): void;

type UseDocumentVisibilityStateReturnType = Document["visibilityState"] | null;
/**
 * useDocumentVisibilityState
 * @description Returns the visibility state of the document. Returns null on the server side.
 * @returns {UseDocumentVisibilityStateReturnType} The visibility state of the document. `null` on the server.
 * @see {@link https://rooks.vercel.app/docs/useDocumentVisibilityState}
 */
declare function useDocumentVisibilityState(): UseDocumentVisibilityStateReturnType;

/**
 * useEffectOnceWhen hook
 *
 * @description It fires a callback once when a condition is true or become true.
 * Fires the callback at most one time.
 *
 * @param callback The callback to fire
 * @param when The condition which needs to be true
 * @see https://rooks.vercel.app/docs/useEffectOnceWhen
 */
declare function useEffectOnceWhen(callback: () => void, when?: boolean): void;

/**
 *  useEventListenerRef hook
 *
 *  A react hook to an event listener to an element
 *  Returns a ref
 *
 * @param {string} eventName The event to track`
 * @param {Function} callback The callback to be called on event
 * @param {object} listenerOptions The options to be passed to the event listener
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @returns {Function} A callback ref that can be used as ref prop
 * @see https://rooks.vercel.app/docs/useEventListenerRef
 */
declare function useEventListenerRef(eventName: string, callback: (...args: unknown[]) => void, listenerOptions?: AddEventListenerOptions | EventListenerOptions | boolean, isLayoutEffect?: boolean): (refElement: RefElementOrNull<HTMLElement>) => void;

type FileDropOptions = {
    accept?: string[];
    maxFileSize?: number;
    maxFiles?: number;
};
type FileDropCallbacks = {
    onDrop?: (acceptedFiles: File[], rejectedFiles: File[]) => void;
    onFileAccepted?: (file: File) => void;
    onFileRejected?: (file: File, reason: string) => void;
    onDragEnter?: (event: DragEvent) => void;
    onDragLeave?: (event: DragEvent) => void;
};
type FileDropRef = (node: HTMLElement | null) => void;
declare function useFileDropRef(options?: FileDropOptions, callbacks?: FileDropCallbacks): FileDropRef;

type CallbackType$1<T, R> = (...args: T[]) => R;
/**
 * useFreshCallback
 * @param callback Any callback function
 * @returns A fresh callback.
 * @see https://rooks.vercel.app/docs/useFreshCallback
 */
declare function useFreshCallback<T, R = void>(callback: CallbackType$1<T, R>): CallbackType$1<T, R>;

/**
 * useFreshRef
 *
 * @param value The value which needs to be fresh at all times. Probably
 * best used with functions
 * @param preferLayoutEffect Should the value be updated using a layout effect
 * or a passive effect. Defaults to false.
 * @returns A ref containing the fresh value
 * @see https://rooks.vercel.app/docs/useFreshRef
 */
declare function useFreshRef<T>(value: T, preferLayoutEffect?: boolean): MutableRefObject<T>;

type CallbackType<T> = (...args: T[]) => void;
/**
 * useFreshTick
 * @param callback The callback to be called on mount
 * @returns A fresh callback.
 * @see https://rooks.vercel.app/docs/useFreshCallback
 */
declare function useFreshTick<T>(callback: CallbackType<T>): CallbackType<T>;

interface UseFullscreenProps {
    target?: RefObject<Element>;
    onChange?: (event: Event) => void;
    onError?: (event: Event) => void;
    requestFullScreenOptions?: FullscreenOptions;
}
/**
 *
 * useFullscreen hook
 *
 * Gives control to make HTML Elements fullscreen.
 *
 * @param {Element | undefined} props.target The target element to be fullscreen.
 * @param {(event: Event) => void} props.onChange The function to be called when the fullscreen changes.
 * @param {(event: Event) => void} props.onError The function to be called when the fullscreen error occurs.
 * @param {FullscreenOptions} props.requestFullscreenOptions The options to be passed to the requestFullscreen function.
 * @return {Object} returns - The controlls of useFullscreen hook.
 * @return {boolean} returns.isFullscreenAvailable - Whether the fullscreen is available.
 * @return {Element | null} returns.fullscreenElement - The fullscreen element.
 * @return {boolean} returns.isFullscreenEnabled - Whether the fullscreen is enabled.
 * @return {() => Promise<void>} returns.enableFullscreen - The function to enable fullscreen.
 * @return {() => Promise<void>} returns.disableFullscreen - The function to disable fullscreen.
 * @return {() => Promise<void>} returns.toggleFullscreen - The function to toggle fullscreen.
 */
declare function useFullscreen(props?: UseFullscreenProps): {
    isFullscreenAvailable: boolean;
    fullscreenElement: Element | null;
    isFullscreenEnabled: boolean;
    enableFullscreen: () => Promise<void>;
    disableFullscreen: () => Promise<void>;
    toggleFullscreen: () => Promise<void>;
};

type FocusProps = FocusEvents;
interface FocusResult<T> {
    /** Props to spread onto the target element. */
    focusProps: DOMAttributes<T>;
}
/**
 * useFocus
 * @description Handles focus events for the immediate target element.
 * @see {@link https://rooks.vercel.app/docs/useFocus}
 */
declare const useFocus: <T extends HTMLElement>(props: FocusProps) => FocusResult<T>;

interface FocusWithinProps {
    /** Handler that is called when the target element or a descendant receives focus. */
    onFocusWithin?: (e: React.FocusEvent) => void;
    /** Handler that is called when the target element and all descendants lose focus. */
    onBlurWithin?: (e: React.FocusEvent) => void;
    /** Handler that is called when the the focus within state changes. */
    onFocusWithinChange?: (isFocusWithin: boolean) => void;
}
interface FocusWithinResult<T> {
    /** Props to spread onto the target element. */
    focusWithinProps: DOMAttributes<T>;
}
/**
 * useFocusWithin
 * @description Handles focus events for the target component.
 * @see {@link https://rooks.vercel.app/docs/useFocusWithin}
 */
declare const useFocusWithin: <T extends HTMLElement>(props: FocusWithinProps) => FocusWithinResult<T>;

/**
 * useForkRef
 * Joins refs together and returns a combination of the two as a new ref
 *
 * @param refA
 * @param refB
 * @returns MutableRefObject
 * @see https://rooks.vercel.app/docs/useForkRef
 */
declare function useForkRef<T>(refA: PossibleRef<T> | null, refB: PossibleRef<T> | null): RefCallback<T> | null;

type UseGetIsMounted = () => () => boolean;
/**
 * @description useGetIsMounted hook checks if a component is mounted or not at the time.
 * Useful for async effects. Returns a callback that returns a boolean representing if the component
 * is mounted at the time.
 * @returns () => boolean
 * @see https://rooks.vercel.app/docs/useGetIsMounted
 */
declare const useGetIsMounted: UseGetIsMounted;

type UseGeoLocationOptions = PositionOptions & {
    when?: boolean;
};
/**
 * useGeolocation
 * Gets the geolocation data as a hook
 *
 * @param {UseGeoLocationOptions} geoLocationOptions Geolocation options
 * @see {@link https://rooks.vercel.app/docs/useGeolocation}
 */
declare const useGeolocation: (geoLocationOptions?: UseGeoLocationOptions) => UseGeolocationReturnType | null;

type InputChangeEvent = ChangeEvent<HTMLInputElement>;
type InputHandler<T> = {
    /**
     * Function to handle onChange of an input element
     *
     * @param event The input change event
     */
    onChange: (event: InputChangeEvent) => void;
    /**
     * The current value of the input
     */
    value: T;
};
type Options$4<T> = {
    /**
     * validate
     *
     * Validator function which can be used to prevent updates
     *
     * @param {any} New value
     * @param {any} Current value
     * @returns {boolean} Whether an update should happen or not
     */
    validate?: (newValue: T, currentValue: T) => boolean;
};
/**
 *
 * useInput Hook
 *
 * Handles an input's value and onChange props internally to
 * make text input creation process easier
 *
 * @param {unknown} [initialValue] Initial value of the input
 * @param {Options} [options] Options object
 * @returns {InputHandler} Input handler with value and onChange
 * @see https://rooks.vercel.app/docs/useInput
 */
declare function useInput<T extends number | string | readonly string[] | undefined = string>(initialValue?: T, options?: Options$4<T>): InputHandler<T>;

/**
 * A setInterval hook that calls a callback after a interval duration
 * when a condition is true
 *
 * @param callback The callback to be invoked after interval
 * @param intervalDurationMs Amount of time in ms after which to invoke
 * @param when The condition which when true, sets the interval
 * @param startImmediate If the callback should be invoked immediately
 * @see https://rooks.vercel.app/docs/useIntervalWhen
 */
declare function useIntervalWhen(callback: () => void, intervalDurationMs?: number, when?: boolean, startImmediate?: boolean): void;

/**
 *
 * useIntersectionObserverRef hook
 *
 * Returns a mutation observer for a React Ref and fires a callback
 *
 * @param {IntersectionObserverCallback} callback Function that needs to be fired on mutation
 * @param {IntersectionObserverInit} options
 * @see https://rooks.vercel.app/docs/useIntersectionObserverRef
 */
declare function useIntersectionObserverRef(callback: IntersectionObserverCallback | undefined, options?: IntersectionObserverInit): [CallbackRef];

declare function useInViewRef(): [CallbackRef, boolean];
declare function useInViewRef(options: IntersectionObserverInit): [CallbackRef, boolean];
declare function useInViewRef(callback: IntersectionObserverCallback, options?: IntersectionObserverInit): [CallbackRef, boolean];

/**
 * useIsDroppingFiles
 * @description Check if any files are currently being dropped anywhere. Useful for highlighting drop areas.
 * @see {@link https://rooks.vercel.app/docs/useIsDroppingFiles}
 */

declare function useIsDroppingFiles(isTargetWindow: true): boolean;
declare function useIsDroppingFiles(isTargetWindow?: false): [CallbackRef<HTMLElement | null>, boolean];

/**
 * useIsomorphicEffect
 * Resolves to useEffect when "window" is not in scope and useLayout effect in the browser
 *
 * @param {Function} callback Callback function to be called on mount
 * @see https://rooks.vercel.app/docs/useIsomorphicEffect
 */
declare const useIsomorphicEffect: typeof useEffect;

type TrackedKeyEvents$2 = "keydown" | "keypress" | "keyup";
type Options$3 = {
    /**
     * Keyboardevent types to listen for. Valid options are keyDown, keyPress and keyUp
     */
    eventTypes?: TrackedKeyEvents$2[];
    /**
     * target mutable ref on which the events should be listened. Doesn't work with callback refs.
     * Please use useKeyRef instead if you want to use with callback refs.
     * If no target is specified, events are listened to on the window. Defaults to window.
     */
    target?: RefObject<HTMLElement>;
    /**
     * Condition which if true, will enable the event listeners
     */
    when?: boolean;
};
/**
 * useKey hook
 *
 * Fires a callback on keyboard events like keyDown, keyPress and keyUp
 *
 * @param {TrackedKeyEvents} keys List of keys to listen for. Eg: ["a", "b"]
 * @param {Callback} callback  Callback to fire on keyboard events
 * @param {Options} options Options
 * @see https://rooks.vercel.app/docs/useKey
 */
declare function useKey(keys: Array<number | string> | number | string, callback: (event: KeyboardEvent) => void, options?: Options$3): void;

type TrackedKeyEvents$1 = "keydown" | "keypress" | "keyup";
type Options$2 = {
    /**
     * Keyboardevent types to listen for. Valid options are keyDown, keyPress and keyUp
     */
    eventTypes?: TrackedKeyEvents$1[];
    /**
     * target ref on which the events should be listened. If no target is specified,
     * events are listened to on the window. Only works with object refs. If you want to use with callback refs,
     * please use useKeyRef instead.
     */
    target?: RefObject<HTMLElement>;
    /**
     * Condition which if true, will enable the event listeners
     */
    when?: boolean;
};
type KeyBindings = {
    [key: string]: (event: KeyboardEvent) => void;
};
/**
 * useKeyBindings
 *
 * useKeyBindings binds pairs of keyboard events and handlers
 *
 * @param { KeyBindings } keyBindings
 * @param {Options} options
 * @see https://rooks.vercel.app/docs/useKeyBindings
 */
declare const useKeyBindings: (keyBindings: KeyBindings, options?: Options$2) => void;

type TrackedKeyEvents = "keydown" | "keypress" | "keyup";
type Callback$2 = (event: KeyboardEvent) => void;
type Options$1 = {
    /**
     * Keyboardevent types to listen for. Valid options are keyDown, keyPress and keyUp
     */
    eventTypes?: TrackedKeyEvents[];
    /**
     * Condition which if true, will enable the event listeners
     */
    when?: boolean;
};
/**
 * useKeyRef hook
 *
 * Fires a callback on keyboard events like keyDown, keyPress and keyUp
 *
 * @param {[string|number]} keys List of keys to listen for. Eg: ["a", "b"]
 * @param {Function} callback Callback to fire on keyboard events
 * @param {Options} options Options
 * @returns {CallbackRef} CallbackRef
 * @see https://rooks.vercel.app/docs/useKeyRef
 */
declare function useKeyRef(keys: Array<number | string> | number | string, callback: Callback$2, options?: Options$1): CallbackRef;

type Options = {
    /**
     * should the event logging be continuous
     */
    continuous?: boolean;
    /**
     * target ref on which the events should be listened. If no target is specified,
     * events are listened to on the document
     */
    target?: MutableRefObject<Document> | MutableRefObject<HTMLElement | null | undefined>;
    /**
     * when boolean to enable and disable events, when passed false
     * remove the eventlistener if any
     */
    when?: boolean;
    /**
     * opt-in to prevent alert, confirm and prompt from causing the eventlistener to lose track of keyup events.
     */
    preventLostKeyup?: boolean;
};
/**
 * useKeys hook
 *
 * @param keysList - list of keys to listen to
 * @param callback  - callback to be called when a key is pressed
 * @param options - options to be passed to the event listener
 * @see https://rooks.vercel.app/docs/useKeys
 */
declare function useKeys(keysList: string[], callback: (event: KeyboardEvent) => void, options?: Options): void;

/**
 * useLifecycleLogger hook
 * logs parameters as component transitions through lifecycles
 *
 * @param componentName Name of the component
 * @param {...*} otherArgs Other arguments to log
 * @see https://rooks.vercel.app/docs/useLifecycleLogger
 */
declare const useLifecycleLogger: (componentName?: string, ...otherArgs: unknown[]) => void;

/**
 * useLockBodyScroll hook
 *
 * This hook locks the scroll of the body element when `isLocked` is set to `true`.
 *
 * @param isLocked Whether or not to lock the body scroll
 * @see https://rooks.vercel.app/docs/useLockBodyScroll
 */
declare function useLockBodyScroll(isLocked: boolean): void;

type UseLocalstorageStateReturnValue<S> = [
    S,
    Dispatch<SetStateAction<S>>,
    () => void
];
/**
 * useLocalstorageState hook
 * Tracks a value within localStorage and updates it
 *
 * @param {string} key - Key of the localStorage object
 * @param {any} initialState - Default initial value
 * @see https://rooks.vercel.app/docs/useLocalstorageState
 */
declare function useLocalstorageState<S>(key: string, initialState?: S | (() => S)): UseLocalstorageStateReturnValue<S>;

type MapControls<K, V> = {
    set: (key: K, value: V) => void;
    remove: (key: K) => void;
    clear: () => void;
    has: (key: K) => boolean;
    get: (key: K) => V | undefined;
    size: () => number;
    setMultiple: (entries: [K, V][]) => void;
    removeMultiple: (keys: K[]) => void;
    hasSome: (keys: K[]) => boolean;
    hasEvery: (keys: K[]) => boolean;
};
declare function useNativeMapState<K, V>(initialMapState?: Map<K, V>): [ReadonlyMap<K, V>, MapControls<K, V>];

/**
 * useMediaMatch
 *
 * A react hook that signals whether or not a media query is matched.
 *
 * @param query The media query to signal on. Example, `"print"` will signal
 * `true` when previewing in print mode, and `false` otherwise.
 * @returns Whether or not the media query is currently matched.
 * @see https://rooks.vercel.app/docs/useMediaMatch
 */
declare function useMediaMatch(query: string): boolean;

/**
 * useMergeRefs
 * Merges multiple refs into a single function ref.
 * Takes any number of refs.
 * Refs can be mutable refs or function refs.
 *
 * @param refs
 * @see https://rooks.vercel.app/docs/useMergeRefs
 */
declare function useMergeRefs<T>(...refs: Array<PossibleRef<T>>): RefCallback<T> | null;

type MouseData = {
    clientX: number | null;
    clientY: number | null;
    movementX: number | null;
    movementY: number | null;
    offsetX: number | null;
    offsetY: number | null;
    pageX: number | null;
    pageY: number | null;
    screenX: number | null;
    screenY: number | null;
    x: number | null;
    y: number | null;
};
/**
 * useMouse hook
 *
 * Retrieves current mouse position and information about the position like
 * screenX, pageX, clientX, movementX, offsetX
 * @see https://rooks.vercel.app/docs/useMouse
 */
declare function useMouse(): MouseData;

type Delta = {
    deltaX: number;
    deltaY: number;
    clientX: number | null;
    clientY: number | null;
    velocityX: number;
    velocityY: number;
    timeStamp: number;
};
type ReturnValue$1 = Omit<Delta, "timeStamp" | "clientX" | "clientY">;
declare function useMouseMoveDelta(): ReturnValue$1;

type MouseWheelDelta = {
    delta: number;
    velocity: number;
    timeStamp: number;
};
type ReturnValue = Omit<MouseWheelDelta, "timeStamp">;
declare function useMouseWheelDelta(): ReturnValue;

type OptionalIndexValue<T> = {
    index?: number;
    value?: T;
};
type OptionalIndicesValues<T> = {
    indices?: number[];
    values?: T[];
};

type UseMultiSelectableListReturnType<T> = [
    Array<number[] | T[]>,
    {
        matchSelection: (parameters: OptionalIndexValue<T>) => boolean;
        toggleSelection: (parameters: OptionalIndexValue<T>) => () => void;
        updateSelections: ({ indices, values, }: OptionalIndicesValues<T>) => () => void;
    }
];
/**
 * useMultiSelectableList
 * A custom hook to easily select multiple values from a list
 *
 * @param list - The list of values to select from
 * @param initialSelectIndices - The indices of the initial selections
 * @param allowUnselected - Whether or not to allow unselected values
 * @see https://rooks.vercel.app/docs/useMultiSelectableList
 */
declare function useMultiSelectableList<T>(list?: T[], initialSelectIndices?: number[], allowUnselected?: boolean): UseMultiSelectableListReturnType<T>;

/**
 *
 * useMutationObserver hook
 *
 * Returns a mutation observer for a React Ref and fires a callback
 *
 * @param {MutableRefObject<HTMLElement | null>} ref React ref on which mutations are to be observed
 * @param {MutationCallback} callback Function that needs to be fired on mutation
 * @param {MutationObserverInit} options
 * @see https://rooks.vercel.app/docs/useMutationObserver
 */
declare function useMutationObserver(ref: MutableRefObject<HTMLElement | null>, callback: MutationCallback, options?: MutationObserverInit): void;

/**
 *
 * useMutationObserverRef hook
 *
 * Returns a mutation observer for a React Ref and fires a callback
 *
 * @param {MutationCallback} callback Function that needs to be fired on mutation
 * @param {MutationObserverInit} options
 * @see https://rooks.vercel.app/docs/useMutationObserverRef
 */
declare function useMutationObserverRef(callback: MutationCallback, options?: MutationObserverInit): [CallbackRef];

type Language = string | null;
/**
 * useNavigatorLanguage hook
 * Returns the language of the navigator
 *
 * @returns {Language}
 * @see https://rooks.vercel.app/docs/useNavigatorLanguage
 */
declare function useNavigatorLanguage(): Language;

/**
 * useOnClickRef hook
 *
 * This hook runs a callback for both clicks and tap events when the element is clicked or tapped.
 *
 * @param {Function} onClick The callback function to run on click or tap
 * @returns {Function} A callback ref which can be attached to an element
 */
declare function useOnClickRef(onClick: () => void): (element: HTMLElement) => void;

type MouseEventHandler = (event: MouseEvent) => void;
declare function useOnHoverRef(onMouseEnter?: MouseEventHandler, onMouseLeave?: MouseEventHandler): RefCallback<HTMLElement>;

/**
 *
 * useOnWindowResize hook
 *
 * Fires a callback when window resizes
 *
 * @param {Function} callback Callback to be called before unmount
 * @param {boolean} when When the handler should be applied
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @see https://rooks.vercel.app/docs/useOnWindowResize
 */
declare function useOnWindowResize(callback: EventListener, when?: boolean, isLayoutEffect?: boolean): void;

/**
 *
 * useOnWindowScroll hook
 * Fires a callback when window scroll
 *
 * @param {Function} callback Callback to be called before unmount
 * @param {boolean} when When the handler should be applied
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @see https://rooks.vercel.app/docs/useOnWindowScroll
 *
 */
declare function useOnWindowScroll(callback: EventListener, when?: boolean, isLayoutEffect?: boolean): void;

/**
 * useOnline hook
 *
 * Returns true if navigator is online, false if not.
 *
 * @returns {boolean} The value of navigator.onLine
 * @see https://rooks.vercel.app/docs/useOnline
 */
declare function useOnline(): boolean | null;

declare const useOrientation: () => ScreenOrientation | null;

/**
 * useOutsideClick hook
 * Checks if a click happened outside a Ref. Handy for dropdowns, modals and popups etc.
 *
 * @param ref Ref whose outside click needs to be listened to
 * @param handler Callback to fire on outside click
 * @param when A boolean which which activates the hook only when it is true. Useful for conditionally enable the outside click
 * @see https://rooks.vercel.app/docs/useOutsideClick
 * @example
 * ```tsx
 * import { useOutsideClick } from "@/hooks/useOutsideClick";
 * import { useRef } from "react";
 * import { noop } from "@/utils/noop";
 *
 * const MyComponent = () => {
 *  const ref = useRef<HTMLDivElement>(null);
 *  const [isOpen, setIsOpen] = useState(false);
 *    const handleOutsideClick = () => setIsOpen(false);
 *  useOutsideClick(ref, handleOutsideClick);
 *  return (
 *   <div ref={ref}>
 *    <button onClick={() => setIsOpen(true)}>Open</button>
 *   {isOpen && (
 *   <div>Inside</div>
 *   )}
 * </div>
 * );
 * }
 * ```
 */
declare function useOutsideClick(ref: MutableRefObject<HTMLElement | null>, handler: (event: MouseEvent) => void, when?: boolean): void;

/**
 * useOutsideClickRef hook
 * Checks if a click happened outside a Ref. Handy for dropdowns, modals and popups etc.
 *
 * @param handler Callback to fire on outside click
 * @param when A boolean which which activates the hook only when it is true. Useful for conditionally enable the outside click
 * @returns An array with first item being ref
 * @see https://rooks.vercel.app/docs/useOutsideClick
 */
declare function useOutsideClickRef(handler: (event: MouseEvent) => void, when?: boolean): [CallbackRef];

/**
 * usePreviousDifferent hook for React
 * It returns the past value which was different from the current one.
 *
 * @param currentValue The value whose previously different value is to be tracked
 * @returns The previous value
 * @see https://rooks.vercel.app/docs/usePreviousDifferent
 */
declare function usePreviousDifferent<T>(currentValue: T): T | null;

/**
 * usePreviousImmediate hook for React
 *
 * @param currentValue The value whose previous value is to be tracked
 * @returns The previous value
 * @see https://rooks.vercel.app/docs/usePreviousImmediate
 */
declare function usePreviousImmediate<T>(currentValue: T): T | null;

/**
 * usePromise
 * @description Promise management hook for react
 * @see {@link https://rooks.vercel.app/docs/usePromise}
 */

type AsyncFunction<T> = () => Promise<T>;
type PromiseState<T> = {
    data: T | null;
    loading: boolean;
    error: Error | null;
};
declare function usePromise<T>(asyncFunction: AsyncFunction<T>, deps?: DependencyList): PromiseState<T>;

/**
 * useQueueState
 * Manages a queue with react hooks.
 * @param initialList Initial value of the list
 * @returns The list and controls to modify the queue
 * @see https://rooks.vercel.app/docs/useQueueState
 */
declare function useQueueState<T>(initialList: T[]): [
    T[],
    {
        dequeue: () => T | undefined;
        enqueue: (item: T) => number;
        length: number;
        peek: () => T | undefined;
    }
];

/**
 *
 * useRaf
 * Uses a polyfilled version of requestAnimationFrame
 *
 * @param {Function} callback The callback function to be executed
 * @param {boolean} [isActive] The value which while true, keeps the raf running infinitely
 * @see https://rooks.vercel.app/docs/useRaf
 */
declare function useRaf(callback: (timeElapsed: number) => void, isActive: boolean): void;

/**
 *
 * useResizeObserverRef hook
 *
 * Returns a resize observer for a React Ref and fires a callback
 * https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
 *
 * @param {ResizeObserverCallback} callback Function that needs to be fired on resize
 * @param {ResizeObserverOptions} options An options object allowing you to set options for the observation
 * @returns {[CallbackRef]} callbackref
 * @see https://rooks.vercel.app/docs/useResizeObserverRef
 */
declare function useResizeObserverRef(callback: ResizeObserverCallback | undefined, options?: ResizeObserverOptions): [CallbackRef];

/**
 * useRenderCount
 * @description Get the render count of a component
 * @see {@link https://rooks.vercel.app/docs/useRenderCount}
 */
declare function useRenderCount(): number;

/**
 * useRefElement hook for React
 * Helps bridge gap between callback ref and state
 * Manages the element called with callback ref api using state variable
 * @returns {[RefElementOrNull, (element: HTMLElementOrNull) => void]}
 * @see https://rooks.vercel.app/docs/useRefElement
 */
declare function useRefElement<T>(): [
    (refElement: RefElementOrNull<T>) => void,
    RefElementOrNull<T>
];

/**
 * useSafeSetState
 * @description set state but ignores if component has already unmounted
 * @see {@link https://rooks.vercel.app/docs/useSafeSetState}
 */

declare function useSafeSetState<T>(initialState: T): [T, Dispatch<SetStateAction<T>>];

type SelectHandler<T> = {
    index: number;
    item: T;
    setIndex: (newIndex: number) => void;
    setItem: (newItem: T) => void;
};
/**
 * useSelect hook
 * Helps easily select a value from a list of values
 *
 * @param list List of values to select a value from
 * @param {number} initialIndex Initial index which is selected
 * @returns handler
 * @see https://rooks.vercel.app/docs/useSelect
 */
declare function useSelect<T>(list: T[], initialIndex?: number): SelectHandler<T>;

type Selection<T> = [number, T];
type UseSelectableListReturnType<T> = [
    Selection<T>,
    {
        matchSelection: (parameters: OptionalIndexValue<T>) => boolean;
        toggleSelection: (parameters: OptionalIndexValue<T>) => () => void;
        updateSelection: (parameters: OptionalIndexValue<T>) => () => void;
    }
];
/**
 * useSelectableList
 * Easily select a single value from a list of values. very useful for radio buttons, select inputs  etc.
 *
 * @param list - The list of values to select from
 * @param initialIndex  - The index of the initial selection
 * @param allowUnselected
 * @see https://rooks.vercel.app/docs/useSelectableList
 */
declare function useSelectableList<T>(list?: T[], initialIndex?: number, allowUnselected?: boolean): UseSelectableListReturnType<T>;

type UseSessionstorateStateReturnValue<S> = [
    S,
    Dispatch<SetStateAction<S>>,
    () => void
];
/**
 * useSessionstorageState hook
 * Tracks a value within sessionStorage and updates it
 *
 * @param {string} key - Key of the sessionStorage object
 * @param {any} initialState - Default initial value
 * @returns {[any, Dispatch<SetStateAction<any>>, () => void]}
 * @see https://rooks.vercel.app/docs/useSessionstorageState
 */
declare function useSessionstorageState<S>(key: string, initialState?: S | (() => S)): UseSessionstorateStateReturnValue<S>;

type Add<T> = (...args: Parameters<Set<T>["add"]>) => void;
type Delete<T> = (...args: Parameters<Set<T>["delete"]>) => void;
type UseSetStateControls<T> = {
    add: Add<T>;
    delete: Delete<T>;
    clear: () => void;
};
type UseSetStateReturnValue<T> = [Set<T>, UseSetStateControls<T>];
/**
 * useSetState
 * @description Manage the state of a Set in React.
 * @param {Set<T>} initialSetValue The initial value of the set to manage.
 * @returns {UseSetStateReturnValue<T>} The state of the Set and the controls.
 * @see {@link https://rooks.vercel.app/docs/useSetState}
 * @example
 * import { useSetState } from "@/hooks/useSetState";
 * const [set, setControls] = useSetState(new Set());
 * setControls.add(1); // {1}
 * setControls.add(2); // {1, 2}
 * setControls.delete(1); // {2}
 * setControls.clear(); // {}
 *
 */
declare function useSetState<T>(initialSetValue: Set<T>): UseSetStateReturnValue<T>;

/**
 * useStackState
 * @description Manages a stack with react hooks.
 * @param initialList Initial value of the list
 * @returns The list and controls to modify the stack
 * @see https://rooks.vercel.app/docs/useStackState
 */
declare function useStackState<T>(initialList: T[]): [
    T[],
    {
        clear: () => void;
        isEmpty: () => boolean;
        length: number;
        peek: () => T | undefined;
        pop: () => T | undefined;
        push: (item: T) => number;
    },
    T[]
];

interface UseSpeechOptions {
    text: string;
    language?: string;
    voiceURI?: string;
    onEnd?: () => void;
    volume?: number;
    pitch?: number;
    rate?: number;
}
interface SpeechControls {
    start: () => void;
    pause: () => void;
    resume: () => void;
    stop: () => void;
    isPlaying: boolean;
}
declare function useSpeech(options: UseSpeechOptions): SpeechControls;

type UpdateValueOptions = {
    overwriteLastEntry?: boolean;
};
type UseTimeTravelStateControls<T> = {
    backLength: number;
    forwardLength: number;
    go: (step: number) => void;
    back: (step?: number) => void;
    forward: (step?: number) => void;
    reset: (newInitialValue?: T) => void;
    undo: (step?: number) => void;
    redo: (step?: number) => void;
    canUndo: boolean;
    canRedo: boolean;
};
type UpdateValue<T> = (val: T | ((prevValue: T) => T), options?: UpdateValueOptions) => void;
type UseTimeTravelStateReturnValue<T> = [
    value: T,
    setValue: UpdateValue<T>,
    controls: UseTimeTravelStateControls<T>
];
/**
 * useTimeTravelState
 * @description A hook that manages state which can undo and redo. A more powerful version of useUndoState hook.
 * @see {@link https://rooks.vercel.app/docs/useTimeTravelState}
 * @param initialValue The initial value of the state.
 * @returns {UseTimeTravelStateReturnValue}
 * @example
 * const [value, setValue, controls] = useTimeTravelState(0);
 * setValue(1);
 * setValue(2);
 * setValue(3);
 * controls.back(); // value === 2
 * controls.back(); // value === 1
 * controls.forward(); // value === 2
 * controls.forward(); // value === 3
 * controls.reset(); // value === 0
 * controls.reset(5); // value === 5
 * controls.back(2); // value === 3
 *
 * setValue(1);
 * setValue(2);
 * setValue(6, { overwriteLastEntry: true });
 * setValue(7, { overwriteLastEntry: true });
 *
 * controls.back(2); // value === 1
 *
 */
declare function useTimeTravelState<T>(initialValue: T): UseTimeTravelStateReturnValue<T>;

type Callback$1<T> = (...args: T[]) => void;
/**
 * useThrottle
 * Throttles a function with a timeout and ensures
 * that the callback function runs at most once in that duration
 *
 * @param callback The callback to throttle
 * @param timeout Throttle timeout
 * @returns [Callback, isReady] The throttled callback and if it is currently throttled
 * @see https://rooks.vercel.app/docs/useThrottle
 */
declare function useThrottle<T>(callback: Callback$1<T>, timeout?: number): [Callback$1<T>, boolean];

/**
 * A setTimeout hook that calls a callback after a timeout duration
 * when a condition is true
 *
 * @param callback The callback to be invoked after timeout
 * @param timeoutDelayMs Amount of time in ms after which to invoke
 * @param when The condition which when true, sets the timeout
 * @see https://rooks.vercel.app/docs/useTimeoutWhen
 */
declare function useTimeoutWhen(callback: () => void, timeoutDelayMs?: number, when?: boolean, key?: string | number): void;

/**
 * Use toggle hook helps you easily toggle a value.
 * @returns [value, setValue]
 * @see https://rooks.vercel.app/docs/useToggle
 * @example
 * const [boolean, toggle] = useToggle();
 * // value is false
 * // toggle() will change value to true.
 */
declare function useToggle<S = boolean>(): [S, () => void];
declare function useToggle(initialValue: boolean): [boolean, () => void];
/**
 * Use toggle hook helps you easily toggle a value
 *
 * @param initialValue Initial value of the toggle, which will be false if not provided.
 * @param toggleFunction A toggle function. This allows for non boolean toggles
 * @example
 * const [value, toggle] = useToggle("on", _value => _value === "on" ? "off" : "on");
 * // value is "on"
 * // toggle() will change value to "off". Calling it again will change value to "on".
 */
declare function useToggle<S>(initialValue: S, toggleFunction?: Reducer<S, unknown>): [S, Dispatch<unknown>];
/**
 * Use toggle hook helps you easily toggle a value
 *
 * @param initialValue Initial value of the toggle, which will be false if not provided.
 * @param toggleFunction A toggle function. This allows for non boolean toggles
 * @example
 * const [value, toggle] = useToggle("on", _value => _value === "on" ? "off" : "on");
 * // value is "on"
 * // toggle() will change value to "off". Calling it again will change value to "on".
 */
declare function useToggle<S>(initialValue: S, toggleFunction?: ReducerWithoutAction<S>): [S, DispatchWithoutAction];

/**
 * useUndoState hook
 * Drop in replacement for useState hook but with undo functionality.
 *
 * @typedef UndoStateOptions
 * @type {object}
 * @property {number} maxSize - Maximum number of states to keep in the undo stack.
 * @param {any} defaultValue - Default value to use for the state. This will be the first value in the undo stack.
 * @param {UseUndoStateOptions} options - Options for the undo state. Currently takes the maxSize option.
 * @returns {UseUndoStateReturnValue}
 * @see https://rooks.vercel.app/docs/useUndoState
 */
declare const useUndoState: <T>(defaultValue: Exclude<T, AnyFunction$1>, options?: UseUndoStateOptions) => UseUndoStateReturnValue<T>;

/**
 * useUndoRedoState
 * @description Setstate but can also undo and redo
 * @see {@link https://rooks.vercel.app/docs/useUndoRedoState}
 */

type UndoRedoControls = {
    undo: () => void;
    redo: () => void;
    /**
     * @deprecated
     * Use `isUndoPossible` instead
     */
    canUndo: () => boolean;
    /**
     * @deprecated
     * Use `isRedoPossible` instead
     * */
    canRedo: () => boolean;
    clearUndoStack: () => void;
    clearRedoStack: () => void;
    clearAll: () => void;
    isUndoPossible: boolean;
    isRedoPossible: boolean;
};
/**
 * useUndoRedoState hook
 *
 * This hook manages the state with undo and redo capabilities.
 *
 * @param initialState - The initial state value
 * @param options - An optional object with a `maxDepth` property to limit the history and future arrays
 * @returns A tuple with the current state, a function to update the state, and an object with undo and redo controls
 *
 * @example
 * const [state, setState, controls] = useUndoRedoState(0, { maxDepth: 3 });
 * // state is 0
 * setState(1); // state is 1
 * controls.undo(); // state is 0
 * controls.redo(); // state is 1
 */
declare function useUndoRedoState<T>(initialState: T, options?: {
    maxDepth?: number;
}): [T, Dispatch<SetStateAction<T>>, UndoRedoControls];

type UseVibrateOptions = {
    isEnabled: boolean;
    pattern: number | number[];
};
declare function useVibrate({ isEnabled, pattern }: UseVibrateOptions): void;

/**
 * useVideo
 * @description Video hook for react
 * @see {@link https://rooks.vercel.app/docs/useVideo}
 */

type VideoState = {
    currentTime: number;
    duration: number;
    isPaused: boolean;
    isMuted: boolean;
    volume: number;
};
type VideoControls = {
    play: () => void;
    pause: () => void;
    toggleMute: () => void;
    setVolume: (volume: number) => void;
    setCurrentTime: (time: number) => void;
    fastForward: (seconds: number) => void;
    rewind: (seconds: number) => void;
    toggleFullScreen: () => void;
};
declare const useVideo: () => [
    RefObject<HTMLVideoElement>,
    VideoState,
    VideoControls
];

type PropsRecord = Record<string, unknown>;
declare function useWhyDidYouUpdate(componentName: string, currentProps: PropsRecord, enableLogging?: boolean): void;

type Callback = () => void;
/**
 * useWillUnmount hook
 * Fires a callback just before component unmounts
 *
 * @param {Function} callback Callback to be called before unmount
 * @see https://rooks.vercel.app/docs/useWillUnmount
 */
declare function useWillUnmount(callback: Callback): void;

/**
 *  useWindowEventListener hook
 *
 *  A react hook to an event listener to the window
 *
 * @param {keyof WindowEventMap} eventName The event to track
 * @param {Function} callback The callback to be called on event
 * @param {ListenerOptions} listenerOptions The options to be passed to the event listener
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @returns {undefined}
 * @see https://rooks.vercel.app/docs/useWindowEventListener
 */
declare function useWindowEventListener(eventName: keyof WindowEventMap, callback: (...args: unknown[]) => void, listenerOptions?: ListenerOptions, isLayoutEffect?: boolean): void;

type ScrollPosition = {
    scrollX: Window["scrollX"];
    scrollY: Window["scrollY"];
};
/**
 *
 * useWindowScrollPosition hook
 * A React hook to get the scroll position of the window
 *
 * @returns an object containing scrollX and scrollY values
 * @see https://rooks.vercel.app/docs/useWindowScrollPosition
 */
declare function useWindowScrollPosition(): ScrollPosition;

type WindowDimensions = DeepNullable<Pick<Window, "innerHeight" | "innerWidth" | "outerHeight" | "outerWidth">>;
/**
 * useWindowSize hook
 * A hook that provides information of the dimensions of the window
 *
 * @returns Dimensions of the window
 * @see https://rooks.vercel.app/docs/useWindowSize
 */
declare function useWindowSize(): WindowDimensions;

export { useArrayState, useAsyncEffect, useAudio, useBoundingclientrect, useBoundingclientrectRef, useCountdown, useCounter, useDebounce, useDebounceFn, useDebouncedValue, useDeepCompareEffect, useDidMount, useDidUpdate, useDimensionsRef, useDocumentEventListener, useDocumentTitle, useDocumentVisibilityState, useEffectOnceWhen, useEventListenerRef, useFileDropRef, useFocus, useFocusWithin, useForkRef, useFreshCallback, useFreshRef, useFreshTick, useFullscreen, useGeolocation, useGetIsMounted, useInViewRef, useInput, useIntersectionObserverRef, useIntervalWhen, useIsDroppingFiles, useIsomorphicEffect, useKey, useKeyBindings, useKeyRef, useKeys, useLifecycleLogger, useLocalstorageState, useLockBodyScroll, useMapState, useMediaMatch, useMergeRefs, useMouse, useMouseMoveDelta, useMouseWheelDelta, useMultiSelectableList, useMutationObserver, useMutationObserverRef, useNativeMapState, useNavigatorLanguage, useMapState as useObjectState, useOnClickRef, useOnHoverRef, useOnLongHover, useOnLongHover as useOnLongHoverRef, useOnLongPress, useOnLongPress as useOnLongPressRef, useOnWindowResize, useOnWindowScroll, useOnline, useOrientation, useOutsideClick, useOutsideClickRef, usePreviousDifferent, usePreviousImmediate, usePromise, useQueueState, useRaf, useRefElement, useRenderCount, useResizeObserverRef, useSafeSetState, useSelect, useSelectableList, useSessionstorageState, useSetState, useSpeech, useStackState, useThrottle, useTimeTravelState, useTimeoutWhen, useToggle, useUndoRedoState, useUndoState, useVibrate, useVideo, useWhyDidYouUpdate, useWillUnmount, useWindowEventListener, useWindowScrollPosition, useWindowSize };
